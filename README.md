# Worker-Thread Node JS
## Have you ever thought about, How to improve the performance of Node JS applications?
## How to use Multithreading in a Node js? 
## Ans: We can use the Worker Thread module.

I recently learned about this really cool module that exists in Node JS called worker Threads, and as soon as I learned about them I was like, OK, I have to implement  this because it's really cool. But before I actually show you what they are and how they work, I think I should probably point out the problem that they're aiming to solve. So here's the problem. We're all well aware of the fact that Node is single threaded, and So what that actually means is at any given point in time, our one thread, our application, could only handle one task at a time. And in fact that's the reason why expensive things like input, output. So for example, talking to a database, you're reading contents from a file, those types.

Operations have to happen asynchronously and the reason why they have to happen asynchronously is because if our one precious thread that we have to do our work is busy doing a long running task, all other requests that are kind of coming in are going to have to wait until this one long running task is done. So instead the way that we solve this problem is we take these expensive operations like reading contents from a file or talking to a database and we offload it to somebody else. We use the event loop. We basically in node use a C compiler, but the point is we use somebody else to go do that expensive operation for us which effectively allows our own thread our own one set of hands.

To continue doing work while that is happening simultaneously. But now this is all fine and dandy when you are in fact dealing with something like input output. That can be done asynchronously. But what happens when your situation is different? What happens if you can't do your operation asynchronously? So for example, let's say you've already read all the data in from the database, and what you're reading in from the database is a really, really big data set. We're talking about maybe millions of records worth of data. Right now you're being tasked with doing some sort of data manipulation before you then go back and send it off to the client. The trouble, of course, is at this point the asynchronous task is done. The data has already been read.

Your callback is fired. Your promise is fired. Whatever you're using, it's over. Now you're back on your main thread, You're back in synchronous land. So what's going to be happening is if your one precious thread is busy doing all this data manipulation on this massive giant data set, what's going to end up happening is you're going to take your otherwise really fast Node application and you're going to slow it right down to a crawl. Now I actually have a small little example that I spun up to illustrate this problem in action. 
